#+TITLE: Learning Manim

* Shapes
#+BEGIN_SRC python :tangle explore/shapes.py :comments org :mkdirp yes :padline no
 #!/usr/bin/env python3

from manimlib.imports import *

class MoreShapes(Scene):
    def construct(self):
        circle = Circle(color=PURPLE_A)
        square = Square(fill_color=GOLD_B, fill_opacity=1, color=GOLD_A)
        square.move_to(UP+LEFT)
        circle.surround(square)
        rectangle = Rectangle(height=2, width=3)
        ellipse=Ellipse(width=3, height=1, color=RED)
        ellipse.shift(2*DOWN+2*RIGHT)
        pointer = CurvedArrow(2*RIGHT,5*RIGHT,color=MAROON_C)
        arrow = Arrow(LEFT,UP)
        arrow.next_to(circle,DOWN+LEFT)
        rectangle.next_to(arrow,DOWN+LEFT)
        ring=Annulus(inner_radius=.5, outer_radius=1, color=BLUE)
        ring.next_to(ellipse, RIGHT)

        self.add(pointer)
        self.play(FadeIn(square))
        self.play(Rotating(square),FadeIn(circle))
        self.play(GrowArrow(arrow))
        self.play(GrowFromCenter(rectangle), GrowFromCenter(ellipse), GrowFromCenter(ring))
#+END_SRC

* Adding Text
#+BEGIN_SRC python :tangle explore/add_text.py :comments org :mkdirp yes :padline no
 #!/usr/bin/env python3

from manimlib.imports import *

class TextAdd(Scene):
    def construct(self):
        name = TextMobject("Hemanta Sharma")
        subname = TextMobject("Pythonista")
        nickname = TextMobject("sharmaji")

        subname.next_to(name, DOWN)
        nickname.next_to(name, DOWN)

        self.add(name, subname)
        self.wait(2)
        self.play(Transform(subname, nickname))
        self.wait(2)
        self.play(ApplyMethod(subname.shift, 3 * DOWN))
        self.play(ApplyMethod(name.move_to, UP))

class TextPlay(Scene):
    def construct(self):
        name = TextMobject("Hemanta Sharma")
        subname = TextMobject("Pythonista")
        nickname = TextMobject("Hemuji")

        subname.next_to(name, DOWN)
        nickname.next_to(name, DOWN)

        self.add(name, subname)
        self.wait(2)
        self.play(ApplyMethod(name.set_color, RED))
        self.wait(2)
        self.play(ApplyMethod(subname.scale,2.75))
        self.wait(2)
        self.play(Transform(subname, nickname))
        self.wait(2)
        self.play(ApplyMethod(subname.set_color, YELLOW))
        self.play(ApplyMethod(subname.shift, 3 * DOWN))
        self.play(ApplyMethod(name.shift, UP))
        self.play(ApplyMethod(name.set_color,BLUE))
        self.play(ApplyMethod(subname.next_to, name.get_corner(DOWN+RIGHT),DOWN))
        self.play(ApplyMethod(subname.match_color,name))
        self.play(FadeOut(name, run_time=3), FadeOut(subname, run_time=2))

#+END_SRC

* Adding More text
#+BEGIN_SRC python :tangle explore/add_more_text.py :comments org :mkdirp yes :padline no
 #!/usr/bin/env python3

from manimlib.imports import *

class AddingMoreText(Scene):
    #Playing around with text properties
    def construct(self):
        quote = TextMobject("Imagination is more important than knowledge")
        quote.set_color(RED)
        quote.to_edge(UP)
        quote2 = TextMobject("A person who never made a mistake never tried anything new")
        quote2.set_color(YELLOW)
        author=TextMobject("-Albert Einstein")
        author.scale(0.75)
        author.next_to(quote.get_corner(DOWN+RIGHT),DOWN)

        self.add(quote)
        self.add(author)
        self.wait(2)
        self.play(Transform(quote,quote2),
        ApplyMethod(author.move_to,quote2.get_corner(DOWN+RIGHT)+DOWN+2*LEFT))

        self.play(ApplyMethod(author.scale,1.5))
        author.match_color(quote2)
        self.play(FadeOut(quote))

#+END_SRC
* Shapes And Text
#+BEGIN_SRC python :tangle explore/shape_and_text.py :comments org :mkdirp yes :padline no
 #!/usr/bin/env python3

from manimlib.imports import *

class ShapesAndText(Scene):
    def construct(self):
        square = Square(side_length=5, fill_color=BLUE_A, fill_opacity=0.5)
        label = TextMobject("Pykancha")
        label.scale(2)
        label.bg = BackgroundRectangle(label, fill_color=GREY, fill_opacity=0.3)
        label_group=VGroup(label.bg,label)  #Order matters

        label2=TextMobject("Boxed text",color=BLACK)
        label2.set_color(WHITE)
        label2.scale(2)
        label2.bg=SurroundingRectangle(label2,color=BLUE,fill_color=RED, fill_opacity=.5)
        label2_group=VGroup(label2,label2.bg)
        label2_group.next_to(label_group,DOWN)

        label3=TextMobject("Rainbow")
        label3.scale(2)
        label3.set_color_by_gradient(RED, ORANGE, YELLOW, GREEN, BLUE, PURPLE)
        label3.to_edge(DOWN+LEFT)

        self.add(square)
        self.play(FadeIn(label_group, run_time=5))
        self.play(Rotate(label.bg, PI/2))
        self.play(FadeOut(label2_group, run_time=2))
        self.play(GrowFromCenter(label3, run_time=2))

#+END_SRC
* Rotation & Highlight
#+BEGIN_SRC python :tangle explore/rotation_and_highligh.py :comments org :mkdirp yes :padline no
 #!/usr/bin/env python3

from manimlib.imports import *

class RotateAndHighlight(Scene):
    #Rotation of text and highlighting with surrounding geometries
    def construct(self):
        square=Square(side_length=5,fill_color=YELLOW, fill_opacity=1)
        label=TextMobject("Text at an angle")
        label.bg=BackgroundRectangle(label,fill_opacity=1)
        label_group=VGroup(label.bg,label)  #Order matters
        label_group.rotate(TAU/8)
        label2=TextMobject("Boxed text",color=BLACK)
        label2.bg=SurroundingRectangle(label2,color=BLUE,fill_color=RED, fill_opacity=.5)
        label2_group=VGroup(label2,label2.bg)
        label2_group.next_to(label_group,DOWN)
        label3=TextMobject("Rainbow")
        label3.scale(2)
        label3.set_color_by_gradient(RED, ORANGE, YELLOW, GREEN, BLUE, PURPLE)
        label3.to_edge(DOWN)

        self.add(square)
        self.play(FadeIn(label_group))
        self.play(FadeIn(label2_group))
        self.play(FadeIn(label3))

#+END_SRC

* Latex
#+BEGIN_SRC python :tangle explore/latex_basic.py :comments org :mkdirp yes :padline no
 #!/usr/bin/env python3

from manimlib.imports import *

class BasicEquations(Scene):
    #A short script showing how to use Latex commands
    def construct(self):
        eq1=TextMobject("$\\vec{X}_0 \\cdot \\vec{Y}_1 = 3$")
        eq1.shift(2*UP)
        eq2=TexMobject(r"\vec{F}_{net} = \sum_i \vec{F}_i")
        eq2.shift(2*DOWN)

        self.play(Write(eq1))
        self.play(Write(eq2))
#+END_SRC
* Coloring Equations
#+BEGIN_SRC python :tangle explore/latex_color.py :comments org :mkdirp yes :padline no
 #!/usr/bin/env python3

from manimlib.imports import *

class ColoringEquations(Scene):
    #Grouping and coloring parts of equations
    def construct(self):
        line1=TexMobject(r"\text{The vector } \vec{F}_{net} \text{ is the net }",r"\text{force }",r"\text{on object of mass }")
        line1.set_color_by_tex("force", BLUE)
        line2=TexMobject("m", "\\text{ and acceleration }", "\\vec{a}", ".  ")
        line2.set_color_by_tex_to_color_map({
            "m": YELLOW,
            "{a}": RED
        })
        sentence=VGroup(line1,line2)
        sentence.arrange_submobjects(DOWN, buff=MED_LARGE_BUFF)
        self.play(Write(sentence))

#+END_SRC
* Aligning Text and Using Braces
Let’s look at how to use braces to visually group equations or text together but also how to align text elements. We will first write a program to align elements of two equations but in a somewhat clunky fashion; this is not the most elegant way to accomplish this task. After looking at this first version we will rewrite the code in a more concise fashion that lines everything up even better.

You can find the following code in the manim tutorial file.
** Crude Way
#+BEGIN_SRC python :tangle explore/latex_align_and_braces_crude.py :comments org :mkdirp yes :padline no
#!/usr/bin/env python3

from manimlib.imports import *

class Main(Scene):
    #Using braces to group text together
    def construct(self):
        eq1A = TextMobject("4x + 3y = 0")
#        eq1B = TextMobject("=")
#        eq1C = TextMobject("0")
        eq2A = TextMobject("5x -2y")
        eq2B = TextMobject("=")
        eq2C = TextMobject("3")
#        eq1B.next_to(eq1A,RIGHT)
#        eq1C.next_to(eq1B,RIGHT)
        eq2A.shift(DOWN)
        eq2B.shift(DOWN)
        eq2C.shift(DOWN)
        eq2A.align_to(eq1A,LEFT)
        eq2B.align_to(eq1B,LEFT)
        eq2C.align_to(eq1C,LEFT)

        eq_group=VGroup(eq1A,eq2A)
        braces=Brace(eq_group,LEFT)
        eq_text = braces.get_text("A pair of equations")

        self.add(eq1A, eq1B, eq1C)
        self.add(eq2A, eq2B, eq2C)
        self.play(GrowFromCenter(braces),Write(eq_text))

class UsingBrces(Scene):
    #Using braces to group text together
    def construct(self):
        eq1A = TextMobject("4x + 3y")
        eq1B = TextMobject("=")
        eq1C = TextMobject("0")
        eq2A = TextMobject("5x -2y")
        eq2B = TextMobject("=")
        eq2C = TextMobject("3")
        eq1B.next_to(eq1A,RIGHT)
        eq1C.next_to(eq1B,RIGHT)
        eq2A.shift(DOWN)
        eq2B.shift(DOWN)
        eq2C.shift(DOWN)
        eq2A.align_to(eq1A,LEFT)
        eq2B.align_to(eq1B,LEFT)
        eq2C.align_to(eq1C,LEFT)

        eq_group=VGroup(eq1A,eq2A)
        braces=Brace(eq_group,LEFT)
        eq_text = braces.get_text("A pair of equations")

        self.add(eq1A, eq1B, eq1C)
        self.add(eq2A, eq2B, eq2C)
        self.play(GrowFromCenter(braces),Write(eq_text))

#+END_SRC
To line up parts of the equations on screen we use next_to() and align_to(). For this example we’ve broken the equation into smaller parts and then used next_to() to place the subparts of each equation next to each other and then align_to() to line up the left side of each part of the equation. You can also use UP, DOWN, and RIGHT to align different edges of the mobjects.

We’ve also added a brace to show how to visually group a set of equations. In order to use the braces we must use VGroup() to combine the equations. When we instantiate the braces the first argument is the group and the second argument is where the braces are located relative to the grouping. You can set the text next to the braces using get_text() (this is a little confusing naming because you are setting the text, not getting it). This method does not draw the text on the screen, it is only used to set the location of the text relative to the braces so you will still need to add the text to the screen.

** Nice Way
#+BEGIN_SRC python :tangle explore/latex_align_and_braces_nice.py :comments org :mkdirp yes :padline no
class UsingBracesConcise(Scene):
    #A more concise block of code with all columns aligned
    def construct(self):
        eq1_text=["4","x","+","3","y","=","0"]
        eq2_text=["5","x","-","2","y","=","3"]
        eq1_mob=TexMobject(*eq1_text)
        eq2_mob=TexMobject(*eq2_text)
        eq1_mob.set_color_by_tex_to_color_map({
            "x":RED_B,
            "y":GREEN_C
            })
        eq2_mob.set_color_by_tex_to_color_map({
            "x":RED_B,
            "y":GREEN_C
            })
        for i,item in enumerate(eq2_mob):
            item.align_to(eq1_mob[i],LEFT)
        eq1=VGroup(*eq1_mob)
        eq2=VGroup(*eq2_mob)
        eq2.shift(DOWN)
        eq_group=VGroup(eq1,eq2)
        braces=Brace(eq_group,LEFT)
        eq_text = braces.get_text("A pair of equations")

        self.play(Write(eq1),Write(eq2))
        self.play(GrowFromCenter(braces),Write(eq_text))

#+END_SRC
* Basic Graphs
#+BEGIN_SRC python :tangle explore/graphs.py :comments org :mkdirp yes :padline no
#!/usr/bin/env python3

from manimlib.imports import *

class Main(GraphScene):
    CONFIG = {
        "x_min" : -10,
        "x_max" : 10.3,
        "y_min" : -1.5,
        "y_max" : 1.5,
        "graph_origin" : ORIGIN ,
        "function_color" : RED ,
        "axes_color" : GREEN,
        "x_labeled_nums" :range(-10,12,2),
    }
    def construct(self):
        self.setup_axes(animate=True)
        func_graph=self.get_graph(self.func_to_graph,self.function_color)
        func_graph2=self.get_graph(self.func_to_graph2)
        vert_line = self.get_vertical_line_to_graph(TAU,func_graph,color=YELLOW)
        graph_lab = self.get_graph_label(func_graph, label = "\\cos(x)")
        graph_lab2=self.get_graph_label(func_graph2,label = "\\sin(x)", x_val=-10, direction=UP/2)
        two_pi = TexMobject("x = 2 \\pi")
        label_coord = self.input_to_graph_point(TAU,func_graph)
        two_pi.next_to(label_coord,RIGHT+UP)

        self.play(ShowCreation(func_graph),ShowCreation(func_graph2))
        self.play(ShowCreation(vert_line), ShowCreation(graph_lab), ShowCreation(graph_lab2),ShowCreation(two_pi))

    def func_to_graph(self,x):
        return np.cos(x)

    def func_to_graph2(self,x):
        return np.sin(x)

#+END_SRC
#+BEGIN_SRC python :tangle explore/graph_basic.py :comments org :mkdirp yes :padline no
#!/usr/bin/env python3

from manimlib.imports import *

class PlotFunctions(GraphScene):
    CONFIG = {
        "x_min" : -10,
        "x_max" : 10.3,
        "y_min" : -1.5,
        "y_max" : 1.5,
        "graph_origin" : ORIGIN ,
        "function_color" : RED ,
        "axes_color" : GREEN,
        "x_labeled_nums" :range(-10,12,2),
    }
    def construct(self):
        self.setup_axes(animate=True)
        func_graph=self.get_graph(self.func_to_graph,self.function_color)
        func_graph2=self.get_graph(self.func_to_graph2)
        vert_line = self.get_vertical_line_to_graph(TAU,func_graph,color=YELLOW)
        graph_lab = self.get_graph_label(func_graph, label = "\\cos(x)")
        graph_lab2=self.get_graph_label(func_graph2,label = "\\sin(x)", x_val=-10, direction=UP/2)
        two_pi = TexMobject("x = 2 \\pi")
        label_coord = self.input_to_graph_point(TAU,func_graph)
        two_pi.next_to(label_coord,RIGHT+UP)

        self.play(ShowCreation(func_graph),ShowCreation(func_graph2))
        self.play(ShowCreation(vert_line), ShowCreation(graph_lab), ShowCreation(graph_lab2),ShowCreation(two_pi))

    def func_to_graph(self,x):
        return np.cos(x)

    def func_to_graph2(self,x):
        return np.sin(x)

#+END_SRC
* Assignment
** References
*** Terms
- Targets and moveToTargets
- Animations like FadeOutAndShiftDown
- Group and arrange function with align and justify
- Camera scenes and stuff
*** Transition and presentation
**** Manish gotame:
#+BEGIN_SRC python :tangle samples/manish_gotame_chemical_reaction.py :comments org :mkdirp yes :padline no
#!/usr/bin/env python3
from manimlib.imports import *

class Chemical(Scene):
    def construct(self):
        self.reactionName = ["1) Combination Reaction",
                    "2) Decomposition Reaction",
                    "3) Displacement Reaction",
                    "4) Acid Base Reaction"]
        self.everything()
        self.rectn1()
        self.rectn2()
        self.rectn3()
        self.rectn4()
        self.reactHeating()

    def rectn6(self):
        defn = TextMobject("Chemical reactions that consume energy are called ", "Endothermic Reactions.")
        defn2 = TextMobject("Exothermic reactions can be represented by the general chemical equation:")
        defns = Group(defn, defn2).arrange(DOWN)
        defn[1].set_color(BLUE)
        defn.scale(0.7)
        defn2.scale(0.7)
        defn.to_corner(UP * 3)
        defn2.to_corner(UP * 4)
        for each in defns:
            self.play(Write(each))
        self.wait()

        genEqn = TexMobject("Reactants + ","Heat", " \\rightarrow Products")
        genEqn[1].set_color(RED)
        genEqn.scale(0.7)
        genEqn.shift(UP * 0.9)
        self.add(genEqn)
        self.wait()

        foreg = TextMobject("For Example:").scale(0.7)
        foreg.to_corner(UP * 7 + LEFT * 3.5)
        self.play(FadeIn(foreg))

        # equation examples here

        wordeqn = TexMobject("Nitrogen + Oxygen + ", "Heat", " \\rightarrow Nitric ", "Oxide")
        wordeqn[1].set_color(RED)
        ueqn = TexMobject("N_2 + O_2 ", "+ \\Delta", "\\rightarrow NO")
        beqn = TexMobject("N_2 + O_2 ", "+ \\Delta", "\\rightarrow" , "2", "NO")

        ueqn[1].set_color(RED)
        beqn[1].set_color(RED)
        beqn[3].set_color(RED)
        eqns1 = VGroup(wordeqn, ueqn, TextMobject("")).arrange(DOWN).shift(UP*0.5)

        wordeqn.scale(0.7)
        eqns1.shift(DOWN)
        beqn.shift(DOWN * 0.8)

        self.play(Write(wordeqn))
        self.wait()
        self.play(Write(ueqn))

        self.wait()
        self.play(Transform(ueqn, beqn))
        self.wait()

        self.play(
                FadeOutAndShiftDown(defns),
                FadeOutAndShiftDown(genEqn),
                FadeOutAndShiftDown(foreg),
                FadeOutAndShiftDown(eqns1),
                )

    def reactHeating(self):
        img1 = ImageMobject("endo-v-exo")
        img1.scale(3.5)

        title = TextMobject("Types of Chemical Reactions based on Heating")
        title.to_corner(UP)
        self.add(title)
        self.wait()
        t1 = TextMobject("1) Exothermic Reaction")
        t2 = TextMobject("2) Endothermic Reaction")
        t1.set_color(ORANGE)
        t2.set_color(BLUE)
        types = Group(t1, t2).arrange(DOWN)
        types.shift(UP)

        for e in types:
            self.play(Write(e), run_time=0.8)
        self.wait()
        '''
        self.play(
                FadeOutAndShiftDown(title),
                FadeOutAndShiftDown(types),
            )
        '''

        #self.add(img1)
        self.remove(title)
        # maybe more time for the narrator to explain here
        #self.remove(img1)

        self.play(
                FadeOutAndShiftDown(t2),
                t1.to_edge, UP, run_time=0.8
            )
        # go for each type of reaction

        self.rectn5() # exothermic reaction call
        self.play(
                FadeOutAndShiftDown(t1),
                FadeIn(t2),
                t2.to_edge, UP, run_time=0.8
                )

        self.rectn6() # endothermic reaction call
        self.play(
                FadeOut(t2)
                )

        # differences scene
        # At the moment, I only have an image to show, maybe later I can improve this
        diff = TextMobject("Let's look at the differences between")
        diff2 = TextMobject("Endothermic"," and", " Exothermic ","Reactions")
        diff2[0].set_color(BLUE)
        diff2[2].set_color(RED)
        diffs = VGroup(diff, diff2).arrange(DOWN)
        self.play(Write(diffs))
        self.wait()
        self.remove(diffs)
        self.add(img1)
        self.wait()

    def rectn5(self):
        defn = TextMobject("Chemical reactions that release energy are called ", "Exothermic Reactions. ","In organisms, exothermic reactions are called ", "Catabolic Reactions."," Exothermic reactions can be represented by the general chemical equation:")

        defn[1].set_color(ORANGE)
        defn.scale(0.7)
        defn.to_corner(UP * 3)
        self.play(Write(defn))
        self.wait()

        genEqn = TexMobject("Reactants \\rightarrow Products"," + ", "Heat")
        genEqn[2].set_color(RED)
        genEqn.scale(0.7)
        genEqn.shift(UP * 0.7)
        self.add(genEqn)
        self.wait()

        foreg = TextMobject("For Example:").scale(0.7)
        foreg.to_corner(UP * 7 + LEFT * 3.5)
        self.play(FadeIn(foreg))

        # equation examples here

        wordeqn = TexMobject("Carbon + Oxygen \\rightarrow Carbon Dioxide + ", "Heat")
        wordeqn[1].set_color(RED)
        ueqn = TexMobject("C + O_2 \\rightarrow CO_2 +", "\\Delta ")
        ueqn[1].set_color(RED)
        eqns1 = VGroup(wordeqn, ueqn, TextMobject("")).arrange(DOWN).shift(UP*0.5)

        wordeqn.scale(0.7)
        eqns1.shift(DOWN)

        self.play(Write(wordeqn))
        self.wait()
        self.play(Write(ueqn))

        self.wait()

        self.play(
                FadeOutAndShiftDown(defn),
                FadeOutAndShiftDown(genEqn),
                FadeOutAndShiftDown(foreg),
                FadeOutAndShiftDown(eqns1),
                )


    def rectn1(self):
        title = TextMobject(self.reactionName[0]).set_color(RED)
        title.to_corner(UP)
        defn = TextMobject("When two or more chemical elements or compounds unite to form one complex product, the reaction is said to be a ", "Combination Reaction.")
        defn[1].set_color(RED)
        defn.scale(0.7)
        defn.to_corner(UP * 3)
        self.add(title)
        self.wait()
        self.play(Write(defn))
        self.wait()

        foreg = TextMobject("For Example:").scale(0.7)
        foreg.to_corner(UP * 5.3 + LEFT * 3.5)
        self.play(FadeIn(foreg))

        # equation examples here
        wordeqn = TexMobject("1) Nitrogen + Hydrogen \\rightarrow Ammonia")
        ueqn = TexMobject("N_2+ H_2 \\rightarrow NH_3")
        beqn = TexMobject("N_2+ ", "3", "H_2 \\rightarrow ","2","NH_3")

        beqn[1].set_color(RED)
        beqn[3].set_color(RED)

        eqns1 = VGroup(wordeqn, ueqn).arrange(DOWN).shift(UP*0.5)
        wordeqn.scale(0.7)
        ueqn.scale(1)
        beqn.scale(1).shift(UP * 0.2)

        self.play(Write(wordeqn))
        self.wait()
        self.play(Write(ueqn))

        self.wait()
        self.play(Transform(ueqn, beqn))
        self.wait()

        wordeqn = TexMobject("2) Potassium + Chlorine \\rightarrow Potassium ", " ", "Chloride")
        ueqn = TexMobject("K_2+ Cl_2 \\rightarrow KCl")
        beqn = TexMobject("K_2+ Cl_2 \\rightarrow ", "2", "KCl")
        beqn[1].set_color(RED)
        eqns2 = VGroup(wordeqn, ueqn).arrange(DOWN).shift(DOWN *1.2)

        wordeqn.scale(0.7)
        beqn.shift(DOWN * 1.6)

        self.play(Write(wordeqn))
        self.wait()
        self.play(Write(ueqn))

        self.wait()
        self.play(Transform(ueqn, beqn))
        self.wait()
        self.wait()
        self.play(
                FadeOutAndShiftDown(title),
                FadeOutAndShiftDown(defn),
                FadeOutAndShiftDown(foreg),
                FadeOutAndShiftDown(eqns1),
                FadeOutAndShiftDown(eqns2),
                )

    def rectn2(self):
        title = TextMobject(self.reactionName[1]).set_color(BLUE)
        title.to_corner(UP)
        defn = TextMobject("A", " decomposition reaction ","occurs when a compound is broken down into smaller compounds or elements. ")
        defn[1].set_color(BLUE)

        defn.scale(0.7)
        defn.to_corner(UP * 3)
        self.add(title)
        self.wait()
        self.play(Write(defn))
        self.wait()

        foreg = TextMobject("For Example:").scale(0.7)
        foreg.to_corner(UP * 5.3 + LEFT * 3.5)
        self.play(FadeIn(foreg))

        # equation examples here

        wordeqn = TexMobject("1) Water \\rightarrow Hydrogen + Oxygen")
        ueqn = TexMobject("H_2O\\rightarrow H_2 + O_2")
        beqn = TexMobject("2","H_2O \\rightarrow ","2","H_2 + O_2")
        beqn[0].set_color(RED)
        beqn[2].set_color(RED)
        eqns1 = VGroup(wordeqn, ueqn, TextMobject("")).arrange(DOWN).shift(UP*0.5)
        wordeqn.scale(0.7)
        beqn.shift(UP * 0.25)

        self.play(Write(wordeqn))
        self.wait()
        self.play(Write(ueqn))

        self.wait()
        self.play(Transform(ueqn, beqn))
        self.wait()

        wordeqn = TexMobject("2) Ammonium" " Hyrdoxide \\rightarrow Ammonia + Water")
        ueqn = TexMobject("NH_4OH \\rightarrow NH_3 + H_2O")
        eqns2 = VGroup(wordeqn, ueqn).arrange(DOWN).shift(DOWN *1.2)
        wordeqn.scale(0.7)

        self.play(Write(wordeqn))
        self.wait()
        self.play(Write(ueqn))

        self.wait()
        self.wait()
        self.play(
                FadeOutAndShiftDown(title),
                FadeOutAndShiftDown(defn),
                FadeOutAndShiftDown(foreg),
                FadeOutAndShiftDown(eqns1),
                FadeOutAndShiftDown(eqns2),
                )

    def rectn3(self):
        title = TextMobject(self.reactionName[2]).set_color(GREEN)
        title.to_corner(UP)
        defn = TextMobject("A", " Displacement Reaction ","occurs when one element replaces another element in a compound.")
        defn[1].set_color(GREEN)

        defn.scale(0.7)
        defn.to_corner(UP * 3)
        self.add(title)
        self.wait()
        self.play(Write(defn))
        self.wait()

        foreg = TextMobject("For Example:").scale(0.7)
        foreg.to_corner(UP * 5.3 + LEFT * 3.5)
        self.play(FadeIn(foreg))

        # equation examples here

        wordeqn = TexMobject("1) Calcium + Sulphuric ", " Acid \\rightarrow Calcium Sulphate + Hydrogen")
        ueqn = TexMobject("Ca_2","+","H_2SO_4", "\\rightarrow",  "CaSO_4", "+", "H_2")
        eqns1 = VGroup(wordeqn, ueqn, TextMobject("")).arrange(DOWN).shift(UP*0.4)
        wordeqn.scale(0.7)

        self.play(Write(wordeqn))
        self.wait()
        self.play(Write(ueqn))
        self.wait()

        wordeqn = TexMobject("2) Sodium Chloride + Silver Nitrate \\rightarrow Sodium Nitrate + Silver Chloride")
        ueqn = TexMobject("NaCl + AgNO_3 \\rightarrow NaNO_3 + AgCl")
        eqns2 = VGroup(wordeqn, ueqn).arrange(DOWN).shift(DOWN *1.2)
        wordeqn.scale(0.7)

        self.play(Write(wordeqn))
        self.wait()
        self.play(Write(ueqn))

        self.wait()

        self.play(
                FadeOutAndShiftDown(title),
                FadeOutAndShiftDown(defn),
                FadeOutAndShiftDown(foreg),
                FadeOutAndShiftDown(eqns1),
                FadeOutAndShiftDown(eqns2),
                )

    def rectn4(self):
        title = TextMobject(self.reactionName[3]).set_color(YELLOW)
        title.to_corner(UP)
        defn = TextMobject("When ", "Acid", " and ", "Base", " are reacted together, they form Salt and Water as products. This reaction is called ", "Acid-Base Reaction")
        defn[1].set_color(RED)
        defn[3].set_color(BLUE)
        defn[5].set_color(YELLOW)

        defn.scale(0.7)
        defn.to_corner(UP * 3)
        self.add(title)
        self.wait()
        self.play(Write(defn))
        self.wait()

        foreg = TextMobject("For Example:").scale(0.7)
        foreg.to_corner(UP * 5.3 + LEFT * 3.5)
        self.play(FadeIn(foreg))

        # equation examples here

        wordeqn = TexMobject("1)", " Sodium Hydroxide", " + ", "Hydrochloric Acid ", "\\rightarrow Sodium Chloride + Water")
        wordeqn[1].set_color(BLUE)
        wordeqn[3].set_color(RED)

        ueqn = TexMobject("NaOH ", "+", " HCL", "\\rightarrow NaCl + H_2O")
        ueqn[0].set_color(BLUE)
        ueqn[2].set_color(RED)
        eqns1 = VGroup(wordeqn, ueqn, TextMobject("")).arrange(DOWN).shift(UP*0.3)
        wordeqn.scale(0.7)

        self.play(Write(wordeqn))
        self.wait()
        self.play(Write(ueqn))

        self.wait()
        #self.play(Transform(ueqn, beqn))
#+END_SRC
** Selection
[[output.gif]]

#+BEGIN_SRC python :tangle assignments/selection_question.py :comments org :mkdirp yes :padline no
#!/usr/bin/env python3

from manimlib.imports import *

class ShapesPlay(Scene):
    TEXT_SIZE_F = 1.5
    TOP_LEFT = (LEFT_SIDE + TOP) / TEXT_SIZE_F
    TOP_RIGHT = (RIGHT_SIDE + TOP) / TEXT_SIZE_F
    BOTTOM_LEFT = (LEFT_SIDE + BOTTOM) / TEXT_SIZE_F
    BOTTOM_RIGHT = (RIGHT_SIDE + BOTTOM) / TEXT_SIZE_F

    shapes_info = {
        'circle': (GOLD, ORIGIN),
        'square': (RED_E, TOP_LEFT),
        'triangle': (BLUE_E, TOP_RIGHT),
        'ellipse': (GREY, BOTTOM_RIGHT),
        'rectangle': (MAROON, BOTTOM_LEFT),
    }

    SHAPE_NAMES = shapes_info.keys()

    def gen_shape_text(self, name):
        color, pos = self.shapes_info[name]
        shape_text = TextMobject(name)
        shape_text.set_color(color)
        shape_text.shift(pos)
        return shape_text

    def construct(self):
        texts = [self.gen_shape_text(name) for name in self.SHAPE_NAMES]
        shapes = [self.gen_shape_obj(name) for name in self.SHAPE_NAMES]
        formulas = [self.gen_shape_formula(name) for name in self.SHAPE_NAMES]
        text_animations = [Write(text_obj, run_time=3) for text_obj in texts]

        self.play(*text_animations)
        for text, shape, formula in zip(texts, shapes, formulas):
            self.play(Transform(text, shape, run_time=2))
            formula.next_to(shape, DOWN)
            self.play(Write(formula, run_time=2))

    def gen_shape_obj(self, name):
        circle = Circle(radius=1.0, color=PURPLE_A)
        triangle = Polygon(np.array([0,0,0]), np.array([1,-1,0]),np.array([-1,-1,0]))
        square = Square(side_length=1.0, color=GOLD_A)
        ellipse = Ellipse(width=2, height=1, color=RED)
        rectangle = Rectangle(height=1, width=1.5)

        shapes_map = {
            'circle': circle,
            'triangle': triangle,
            'square': square,
            'rectangle': rectangle,
            'ellipse': ellipse,
            }

        for shape_name, shape_obj in shapes_map.items():
            color, pos = self.shapes_info[shape_name]
            shape_obj.move_to(pos)

        return shapes_map[name]

    def gen_shape_formula(self, name):
        circle = TexMobject(r'\pi r^2')
        triangle = TexMobject(r'\frac{1}{2} base \times height')
        square = TexMobject(r'length^2')
        ellipse = TexMobject(r'\pi a b')
        rectangle = TexMobject(r'length \times breadth')

        formula_map = {
            'circle': circle,
            'triangle': triangle,
            'square': square,
            'rectangle': rectangle,
            'ellipse': ellipse,
            }

        return formula_map[name]
#+END_SRC

** Training
We are building a simple circle and line and translate them to another cirlce sitting on platform and hit it. The ball will fall off with acceleration and go below. The formula for parabola will appear.

#+BEGIN_SRC python :tangle main.py :comments org :mkdirp yes :padline no
#!/usr/bin/env python3

from manimlib.imports import *

class ProjectileMotion(Scene):
    def construct(self):
        BOTTOM_LEFT = BOTTOM + LEFT_SIDE
        arm_line = Line(
            #np.array([-6, 0, 0]), np.array([-6, 3.5, 0])
            BOTTOM_LEFT, BOTTOM_LEFT + 2 * UP
            )
        fist_circle = Circle(radius=0.5)

        platform_line = Line()
        platform_ball = Circle(radius=0.5)

        arm_line.set_angle(PI/4)
        fist_circle.next_to(arm_line, UP+RIGHT)
        platform_ball.next_to(platform_line, UP)

        self.play(*[ShowCreation(i) for i in [arm_line, fist_circle, platform_line, platform_ball]])

        self.play(ApplyMethod(fist_circle.next_to, platform_ball, LEFT))
#+END_SRC

** Assignment 1
*** Script
Video 1: Gravitational Force Numerical

· Show two bodies with mass M1 and M2 with the distance of R2 --> Scene
· Show the formula of gravitational force between two bodies:  --> PiCreatureScene
F = G (M1.M2)/R2
· Ask what happens to the Gravitational Force between them in the following conditions:
§ When the masses are doubled
§ When the distance is doubled
§ When the masses are doubled and the distance is doubled
§ When the masses are doubled and the distance is halved
· Show with calculation, what happens in the aforementioned condition. For example: When the masses are doubled, the final force F2 increase by four times; When the masses are doubled and the distance is doubled, the Final Force F2 does not change at all. SHOW BY CALCULATION.

*** Code
**** Entry point
#+BEGIN_SRC python :tangle run.py :comments org :mkdirp yes :padline no
#!/usr/bin/env python3
from manimlib.imports import *
#+END_SRC
**** First Scene
#+BEGIN_SRC python :tangle run.py :comments org :mkdirp yes :padline no
class M1M2Setup(Scene):
    def construct(self):
        m1_body = Circle()
        m1_center = Dot(point=m1_body.get_center())
        m1_text = TexMobject("M_{1}")
        m1 = VGroup(m1_body, m1_center, m1_text)

        m2_body = Circle()
        m2_center = Dot(point=m1_body.get_center())
        m2_text = TexMobject("M_{2}")
        m2 = VGroup(m2_body, m2_center, m2_text)

        line = Line(1.5 * LEFT, 1.5 * RIGHT)
        line_text = TextMobject("R")
        line_text.next_to(line, UP)

        self.play(ShowCreation(m1_body), run_time=3)
        self.add(m1_center)
        self.play(Write(m1_text), run_time=3)
        self.play(m1.to_edge, LEFT)

        self.play(ShowCreation(m2_body), run_time=3)
        self.add(m2_center)
        self.play(Write(m2_text), run_time=3)
        self.play(m2.to_edge, RIGHT)

        self.play(ShowCreation(line))

        self.play(
            ApplyMethod(m1.move_to, line.start),
            ApplyMethod(m2.move_to, line.end),
            run_time=3,
        )

        self.play(
            ApplyMethod(m1_text.next_to, m1, UP),
            ApplyMethod(m2_text.next_to, m2, UP),
            Write(line_text),
            run_time=3,
        )
#+END_SRC

**** Second Scene
#+BEGIN_SRC python :tangle run.py :comments org :mkdirp yes :padline no
class SpecialCases(PiCreatureScene):
    def construct(self):
        self.show_formula()
        self.list_cases()

    def show_formula(self):
        formula = TexMobject(r"F = G \frac{M_{1} \cdot M_{2}}{R^2}")
        self.say(formula)
        self.blink()
        self.say("")

    def list_cases(self):
        title = TextMobject("What happens when?")
        cases = [
            "Masses are doubled",
            "Distance is doubled",
            "Both masses and the distance is doubled",
            "Masses are doubled and the distance is halved",
        ]
        title.move_to(2 * RIGHT)
        title.to_edge(UP)
        self.play(Write(title))
        cases_obj = [title]
        for case in cases:
            sentence = TextMobject(case)
            sentence.scale(0.75)
            dot = Dot()
            dot.next_to(sentence, LEFT)
            point = VGroup(sentence, dot)
            point.next_to(cases_obj[-1], DOWN)
            self.play(ReplacementTransform(cases_obj[-1].copy(), point), run_time=2)
            cases_obj.append(point)
        self.think("?")
        self.wait(3)

#+END_SRC
**** Third Scene
#+BEGIN_SRC python :tangle run.py :comments org :mkdirp yes :padline no
class Calculation(Scene):
    def construct(self):
        self.mass_doubled()
        self.distance_doubled()
        self.mass_distance_doubled()
        self.mass_doubled_distance_halved()

    def mass_doubled(self):
        title = TextMobject("1. Masses are doubled")
        conditions = [
            r"M_{1} \rightarrow 2 \cdot M_{1}",
            r"M_{2} \rightarrow 2 \cdot M_{2}",
        ]

        self.establish_case(title, conditions)
        cases = [
            r"or, F_{2} = G \frac{2 \times M_{1} \cdot 2 \times M_{2}}{R^2}",
            r"or, F_{2} = 4 \cdot G \frac{M_{1} \cdot M_{2}}{R^2}",
            r"or, F_{2} = 4 \cdot (G \frac{M_{1} \cdot M_{2}}{R^2})",
            r"or, F_{2} = 4 \cdot F",
        ]

        self.show_calculation(cases)

    def distance_doubled(self):
        title = TextMobject("2. Distance between bodies is  doubled")
        conditions = [
            r"R \rightarrow 2 \cdot R",
        ]
        self.establish_case(title, conditions)

        cases = [
            r"or, F_{2} = G \frac{M_{1} \cdot M_{2}}{(2R)^2}",
            r"or, F_{2} = G \frac{M_{1} \cdot M_{2}}{4R^2}",
            r"or, F_{2} = \frac{1}{4} \cdot (G \frac{M_{1} \cdot M_{2}}{R^2})",
            r"or, F_{2} = \frac{1}{4}  \cdot F",
        ]

        self.show_calculation(cases)

    def mass_doubled_distance_halved(self):
        title = TextMobject("4. Masses are doubled but the distance is halved")
        conditions = [
            r"M_{1} \rightarrow 2 \cdot M_{1}",
            r"M_{2} \rightarrow 2 \cdot M_{2}",
            r"R \rightarrow \frac{R}{2}",
        ]

        self.establish_case(title, conditions)
        cases = [
            r"or, F_{2} = G \frac{2 \times M_{1} \cdot 2 \times M_{2}}{(\frac{R}{2})^2}",
            r"or, F_{2} = 4 \cdot G \frac{M_{1} \cdot M_{2}}{\frac{R^2}{4}}",
            r"or, F_{2} = 4 \times 4 \cdot (G \frac{M_{1} \cdot M_{2}}{R^2})",
            r"or, F_{2} = 16 F",
        ]

        self.show_calculation(cases)

    def mass_distance_doubled(self):
        title = TextMobject("3. Both Masses and distance are doubled")
        conditions = [
            r"M_{1} \rightarrow 2 \cdot M_{1}",
            r"M_{2} \rightarrow 2 \cdot M_{2}",
            r"R \rightarrow 2 \cdot R",
        ]

        self.establish_case(title, conditions)
        cases = [
            r"or, F_{2} = G \frac{2 \times M_{1} \cdot 2 \times M_{2}}{(2R)^2}",
            r"or, F_{2} = 4 \cdot G \frac{M_{1} \cdot M_{2}}{4R^2}",
            r"or, F_{2} = 4 \frac{1}{4} \cdot (G \frac{M_{1} \cdot M_{2}}{R^2})",
            r"or, F_{2} = F",
        ]

        self.show_calculation(cases)

    def establish_case(self, title, conditions):
        title.to_edge(UP)
        self.play(Write(title))
        conditions_obj = [title]
        for condition in conditions:
            sentence = TexMobject(condition)
            sentence.next_to(conditions_obj[-1], DOWN, buff=1.0)
            self.play(
                ReplacementTransform(conditions_obj[-1].copy(), sentence), run_time=2
            )
            conditions_obj.append(sentence)
        self.wait(3)
        self.clear()

    def show_calculation(self, steps):
        formula = TexMobject(r"F = G \frac{M_{1} \cdot M_{2}}{R^2}")
        formula.to_edge(UP)
        self.play(Write(formula))
        steps_obj = [formula]
        for step in steps:
            sentence = TexMobject(step)
            sentence.next_to(steps_obj[-1], DOWN, buff=0.5)
            self.play(ReplacementTransform(steps_obj[-1].copy(), sentence), run_time=2)
            steps_obj.append(sentence)
        self.wait(3)
        self.clear()
#+END_SRC
**** Conclusion
#+BEGIN_SRC python :tangle run.py :comments org :mkdirp yes :padline no
SCENES_IN_ORDER = [M1M2Setup, SpecialCases, Calculation]
#+END_SRC
** Assignment 2
*** Script
**** Video 2:  Thermometer
Display ‘thermometer’ as text and transform into the svg image.

What are the parts involved in thermometer. {Use svg image of thermometer having distinct parts labelled.}

Introduction of the thermometric liquids. Reference: https://bloomnepal.sharepoint.com/sites/Class10Content/_layouts/15/Doc.aspx?sourcedoc={5ed75301-9b4a-471f-9cb0-263a5634e47b}&action=edit&wd=target%28Heat.one%7C46a7e678-bd30-4cc3-9e03-e88c1db95c84%2FThermometer%20and%20its%20structure%7Ccc238cd3-08e2-407a-9428-d1d10b64ae6c%2F%29

List out two thermometric liquids.
Mercury.
Alcohol.

Introduction and some characteristics of types of thermometer.

Clinical thermometer: (SVG image of the thermometer)

Range of temperature.

Degree Celsius: 35 to 42

Degree Fahrenheit: 94 to 108

It is used to measure the temperature of the human body.

Laboratory thermometer: (SVG image of the thermometer.)

Range of temperature

–10oC to 100oC

It is used for laboratory purpose.

Maximum and Minimum thermometer. (SVG image of the thermometer.)

Used by meteorologist to understand the temperature of the day. It is used to record the extremes of temperature at a location.

**** Reference:
Thermometer is a device which is designed to measure temperature.

Working principle of thermometer:
"Body expands on heating and contracts on cooling."

The material used inside the thermometer to measure the temperature is called thermometric substance. The thermal expansion of the thermometric substance is measured using the graduated scale of the thermometer.

Parts of thermometer:
A general thermometer consists of a glass stem with a fine and uniform hollow capillary tube inside it. One end of the glass stem is sealed and at the other end, a thin walled bulb  presents inside of which a thermometric liquid is kept. The capillary tube provides space for expansion of thermometric liquid while measuring the temperature of the body. The glass stem is calibrated with standard scales.

Thermometric liquid:
It is the liquid used in the thermometer to measure the temperature.
There are two liquids which we will basically explore in the upcoming sub-topics.

*** Code
**** Entry point
#+BEGIN_SRC python :tangle run.py :comments org :mkdirp yes :padline no
#!/usr/bin/env python3
from manimlib.imports import *
#+END_SRC
